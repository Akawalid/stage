(* #"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 41 4 41 93 *)

(* reversal_raw_ptr::Node<T> *)

let%span sreversal_raw_ptr = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 44 20 44 36
let%span sreversal_raw_ptr'0 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 46 22 46 42
let%span sreversal_raw_ptr'1 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 41 16 41 17
let%span sreversal_raw_ptr'2 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 41 39 41 42
let%span sreversal_raw_ptr'3 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 35 15 35 35
let%span sreversal_raw_ptr'4 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 36 14 36 40
let%span sreversal_raw_ptr'5 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 37 14 37 92
let%span sreversal_raw_ptr'6 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 38 14 38 39
let%span sreversal_raw_ptr'7 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 39 14 39 39
let%span sreversal_raw_ptr'8 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 40 14 40 43
let%span sreversal_raw_ptr'9 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 13 14 13 28
let%span sreversal_raw_ptr'10 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 16 12 25 13
let%span sptr = "/home/baggabom/stage/creusot/creusot-contracts/src/std/ptr.rs" 59 14 59 53
let%span sptr'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/ptr.rs" 61 8 61 35
let%span sseq = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 496 33 496 37
let%span sseq'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 496 39 496 40
let%span sseq'1 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 495 14 495 41
let%span sseq'2 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 169 8 169 39
let%span sseq'3 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 247 8 247 27
let%span sseq'4 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 673 20 673 95
let%span sghost = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 79 22 79 26
let%span sghost'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 79 4 79 48
let%span sghost'1 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 77 14 77 31
let%span sghost'2 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 78 14 78 31
let%span sghost'3 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 183 22 183 26
let%span sghost'4 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 183 4 183 32
let%span sghost'5 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 181 14 181 29
let%span sghost'6 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 162 14 162 26
let%span sghost'7 = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 99 8 99 18
let%span sboxed = "/home/baggabom/stage/creusot/creusot-contracts/src/std/boxed.rs" 33 8 33 18
let%span sptr_own = "/home/baggabom/stage/creusot/creusot-contracts/src/ptr_own.rs" 57 15 57 16
let%span sptr_own'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/ptr_own.rs" 57 4 57 53
let%span sptr_own'1 = "/home/baggabom/stage/creusot/creusot-contracts/src/ptr_own.rs" 56 14 56 64
let%span sptr_own'2 = "/home/baggabom/stage/creusot/creusot-contracts/src/ptr_own.rs" 49 8 49 35
let%span sresolve = "/home/baggabom/stage/creusot/creusot-contracts/src/resolve.rs" 49 20 49 34
let%span sinvariant = "/home/baggabom/stage/creusot/creusot-contracts/src/invariant.rs" 101 20 101 44

use creusot.prelude.Opaque
use creusot.int.UInt64
use creusot.prelude.MutBorrow
use seq.Seq
use mach.int.Int
use creusot.prelude.Any

type t_T

type t_Node  =
  { t_Node__elem: t_T; t_Node__next: Opaque.ptr }

type t_PtrOwn  =
  { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }

type tuple  =
  { _p0: Opaque.ptr; _p1:  t_PtrOwn }

predicate inv (_0 : t_T)

predicate inv'0 (_0 : t_Node)

axiom inv_axiom [@rewrite] : forall x : t_Node [inv'0 x] . inv'0 x
= match x with
  | {t_Node__elem = elem ; t_Node__next = next} -> inv elem
  end

function addr_logic (self : Opaque.ptr) : UInt64.t

function is_null_logic (self : Opaque.ptr) : bool =
  [%#sptr'0] addr_logic self = (0 : UInt64.t)

axiom is_null_logic_spec : forall self : Opaque.ptr . [%#sptr] is_null_logic self = (addr_logic self = (0 : UInt64.t))

function ptr (self : t_PtrOwn) : Opaque.ptr

predicate invariant' (self : t_PtrOwn) =
  [%#sptr_own'2] not is_null_logic (ptr self)

predicate invariant''0 (self : t_Node) =
  [%#sboxed] inv'0 self

predicate inv'1 (_0 : t_Node)

axiom inv_axiom'0 [@rewrite] : forall x : t_Node [inv'1 x] . inv'1 x = invariant''0 x

predicate inv'2 (_0 : t_PtrOwn)

axiom inv_axiom'1 [@rewrite] : forall x : t_PtrOwn [inv'2 x] . inv'2 x
= (invariant' x
/\ match x with
  | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'1 val'
  end)

predicate invariant''1 (self :  t_PtrOwn) =
  [%#sghost'7] inv'2 self

predicate inv'3 (_0 :  t_PtrOwn)

axiom inv_axiom'2 [@rewrite] : forall x :  t_PtrOwn [inv'3 x] . inv'3 x = invariant''1 x

predicate inv'4 (_0 : tuple)

axiom inv_axiom'3 [@rewrite] : forall x : tuple [inv'4 x] . inv'4 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'3 x1)

function val' (self : t_PtrOwn) : t_Node

let rec new (v:t_Node) (return'  (x:tuple))= {[@expl:new 'v' type invariant] [%#sptr_own] inv'0 v}
  any
  [ return''0 (result:tuple)-> {[%#sptr_own'0] inv'4 result}
    {[%#sptr_own'1] ptr result._p1 = result._p0 /\ val' result._p1 = v}
    (! return' {result}) ]


predicate invariant''2 (self : t_PtrOwn) =
  [%#sboxed] inv'2 self

predicate inv'5 (_0 : t_PtrOwn)

axiom inv_axiom'4 [@rewrite] : forall x : t_PtrOwn [inv'5 x] . inv'5 x = invariant''2 x

predicate invariant''3 (self : Seq.seq t_PtrOwn) =
  [%#sseq'4] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'5 (Seq.get self i)

predicate inv'6 (_0 : Seq.seq t_PtrOwn)

axiom inv_axiom'5 [@rewrite] : forall x : Seq.seq t_PtrOwn [inv'6 x] . inv'6 x = invariant''3 x

predicate invariant''4 (self :  (Seq.seq t_PtrOwn)) =
  [%#sghost'7] inv'6 self

predicate inv'7 (_0 :  (Seq.seq t_PtrOwn))

axiom inv_axiom'6 [@rewrite] : forall x :  (Seq.seq t_PtrOwn) [inv'7 x] . inv'7 x = invariant''4 x

predicate invariant''5 (self : MutBorrow.t ( (Seq.seq t_PtrOwn))) =
  [%#sinvariant] inv'7 self.current /\ inv'7 self.final

predicate inv'8 (_0 : MutBorrow.t ( (Seq.seq t_PtrOwn)))

axiom inv_axiom'7 [@rewrite] : forall x : MutBorrow.t ( (Seq.seq t_PtrOwn)) [inv'8 x] . inv'8 x = invariant''5 x

predicate invariant''6 (self : MutBorrow.t (Seq.seq t_PtrOwn)) =
  [%#sinvariant] inv'6 self.current /\ inv'6 self.final

predicate inv'9 (_0 : MutBorrow.t (Seq.seq t_PtrOwn))

axiom inv_axiom'8 [@rewrite] : forall x : MutBorrow.t (Seq.seq t_PtrOwn) [inv'9 x] . inv'9 x = invariant''6 x

let rec deref_mut (self:MutBorrow.t ( (Seq.seq t_PtrOwn))) (return'  (x:MutBorrow.t (Seq.seq t_PtrOwn)))= {[@expl:deref_mut 'self' type invariant] [%#sghost] inv'8 self}
  any
  [ return''0 (result:MutBorrow.t (Seq.seq t_PtrOwn))-> {[%#sghost'0] inv'9 result}
    {[%#sghost'1] result.current = self.current}
    {[%#sghost'2] result.final = self.final}
    (! return' {result}) ]


let rec into_inner (self: t_PtrOwn) (return'  (x:t_PtrOwn))= {[@expl:into_inner 'self' type invariant] [%#sghost'3] inv'3 self}
  any [ return''0 (result:t_PtrOwn)-> {[%#sghost'4] inv'2 result} {[%#sghost'5] result = self} (! return' {result}) ] 

function push_front [@inline:trivial] (self : Seq.seq t_PtrOwn) (x : t_PtrOwn) : Seq.seq t_PtrOwn =
  [%#sseq'3] Seq.cons x self

let rec push_front_ghost (self:MutBorrow.t (Seq.seq t_PtrOwn)) (x:t_PtrOwn) (return'  (x'0:()))= {[@expl:push_front_ghost 'self' type invariant] [%#sseq] inv'9 self}
  {[@expl:push_front_ghost 'x' type invariant] [%#sseq'0] inv'2 x}
  any [ return''0 (result:())-> {[%#sseq'1] self.final = push_front self.current x} (! return' {result}) ] 

predicate resolve (self : MutBorrow.t (Seq.seq t_PtrOwn)) =
  [%#sresolve] self.final = self.current

predicate resolve'0 (_0 : MutBorrow.t (Seq.seq t_PtrOwn)) =
  resolve _0

predicate resolve'1 (self : MutBorrow.t ( (Seq.seq t_PtrOwn))) =
  [%#sresolve] self.final = self.current

predicate resolve'2 (_0 : MutBorrow.t ( (Seq.seq t_PtrOwn))) =
  resolve'1 _0

let rec new'0 (x:()) (return'  (x'0: ()))= any
  [ return''0 (result: ())-> {[%#sghost'6] result = x} (! return' {result}) ]


function tail (self : Seq.seq t_PtrOwn) : Seq.seq t_PtrOwn =
  [%#sseq'2] Seq.([..]) self 1 (Seq.length self)

predicate list [#"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 14 4 14 68] (l : Opaque.ptr) (perm_seq : Seq.seq t_PtrOwn)


axiom list_def : forall l : Opaque.ptr, perm_seq : Seq.seq t_PtrOwn . list l perm_seq
= ([%#sreversal_raw_ptr'10] if is_null_logic l then
  Seq.length perm_seq = 0
else
  if Seq.length perm_seq > 0 then
    let ptr'0 = ptr (Seq.get perm_seq 0) in l = ptr'0 /\ list (val' (Seq.get perm_seq 0)).t_Node__next (tail perm_seq)
  else
    false

)

meta "compute_max_steps" 1000000

let rec cons[#"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 41 4 41 93] (e:t_T) (l:Opaque.ptr) (seq:MutBorrow.t ( (Seq.seq t_PtrOwn))) (return'  (x:Opaque.ptr))= {[@expl:cons 'e' type invariant] [%#sreversal_raw_ptr'1] inv e}
  {[@expl:cons 'seq' type invariant] [%#sreversal_raw_ptr'2] inv'8 seq}
  {[@expl:cons requires] [%#sreversal_raw_ptr'3] list l seq.current}
  (! bb0
  [ bb0 = bb1
  | bb1 = s0 [ s0 =  [ &_13 <- { t_Node__elem = e'0; t_Node__next = l'0 } ] s1 | s1 = bb2 ] 
  | bb2 = s0 [ s0 = new {_13} (fun (_ret:tuple) ->  [ &_12 <- _ret ] s1) | s1 = bb3 ] 
  | bb3 = s0
    [ s0 =  [ &raw <- _12._p0 ] s1
    | s1 =  [ &own <- _12._p1 ] s2
    | s2 =  [ &_seq2 <- [%#sreversal_raw_ptr] seq'0.current ] s3
    | s3 = bb4 ]
  
  | bb4 = s0
    [ s0 = {inv'7 seq'0.current}
      MutBorrow.borrow_final < (Seq.seq t_PtrOwn)> {seq'0.current} {MutBorrow.get_id seq'0}
        (fun (_ret:MutBorrow.t ( (Seq.seq t_PtrOwn))) ->
           [ &_22 <- _ret ] 
          -{inv'7 _ret.final}-
           [ &seq'0 <- { seq'0 with current = _ret.final } ] 
          s1)
    | s1 = deref_mut {_22} (fun (_ret:MutBorrow.t (Seq.seq t_PtrOwn)) ->  [ &_21 <- _ret ] s2)
    | s2 = bb5 ]
  
  | bb5 = s0 [ s0 = into_inner {own} (fun (_ret:t_PtrOwn) ->  [ &_23 <- _ret ] s1) | s1 = bb6 ] 
  | bb6 = s0
    [ s0 = {inv'6 _21.current}
      MutBorrow.borrow_final <Seq.seq t_PtrOwn> {_21.current} {MutBorrow.get_id _21}
        (fun (_ret:MutBorrow.t (Seq.seq t_PtrOwn)) ->
           [ &_20 <- _ret ] 
          -{inv'6 _ret.final}-
           [ &_21 <- { _21 with current = _ret.final } ] 
          s1)
    | s1 = push_front_ghost {_20} {_23} (fun (_ret:()) ->  [ &_19 <- _ret ] s2)
    | s2 = bb7 ]
  
  | bb7 = s0
    [ s0 = {[@expl:type invariant] inv'9 _21} s1
    | s1 = -{resolve'0 _21}- s2
    | s2 = {[@expl:type invariant] inv'8 seq'0} s3
    | s3 = -{resolve'2 seq'0}- s4
    | s4 = new'0 {_19} (fun (_ret: ()) ->  [ &_18 <- _ret ] s5)
    | s5 = bb8 ]
  
  | bb8 = s0
    [ s0 = {[@expl:assertion] [%#sreversal_raw_ptr'0] _seq2 = tail seq'0.current} s1
    | s1 =  [ &_0 <- raw ] s2
    | s2 = bb9 ]
  
  | bb9 = return''0 {_0} ]
  )
  [ & _0 : Opaque.ptr = Any.any_l ()
  | & e'0 : t_T = e
  | & l'0 : Opaque.ptr = l
  | & seq'0 : MutBorrow.t ( (Seq.seq t_PtrOwn)) = seq
  | & raw : Opaque.ptr = Any.any_l ()
  | & own :  t_PtrOwn = Any.any_l ()
  | & _12 : tuple = Any.any_l ()
  | & _13 : t_Node = Any.any_l ()
  | & _seq2 : Seq.seq t_PtrOwn = Any.any_l ()
  | & _18 :  () = Any.any_l ()
  | & _19 : () = Any.any_l ()
  | & _20 : MutBorrow.t (Seq.seq t_PtrOwn) = Any.any_l ()
  | & _21 : MutBorrow.t (Seq.seq t_PtrOwn) = Any.any_l ()
  | & _22 : MutBorrow.t ( (Seq.seq t_PtrOwn)) = Any.any_l ()
  | & _23 : t_PtrOwn = Any.any_l () ]
  
  [ return''0 (result:Opaque.ptr)-> {[@expl:cons ensures #0] [%#sreversal_raw_ptr'4] list result seq.final}
    {[@expl:cons ensures #1] [%#sreversal_raw_ptr'5] forall i : int . 0 <= i /\ i < Seq.length (tail seq.final)
     -> Seq.get seq.current i = Seq.get (tail seq.final) i}
    {[@expl:cons ensures #2] [%#sreversal_raw_ptr'6] (val' (Seq.get seq.final 0)).t_Node__elem = e}
    {[@expl:cons ensures #3] [%#sreversal_raw_ptr'7] ptr (Seq.get seq.final 0) = result}
    {[@expl:cons ensures #4] [%#sreversal_raw_ptr'8] Seq.length seq.final = Seq.length seq.current + 1}
    (! return' {result}) ]
  
