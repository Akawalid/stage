(* #"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 31 4 31 65 *)

(* reversal_raw_ptr::Node<T> *)

let%span sreversal_raw_ptr = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 31 22 31 65
let%span sreversal_raw_ptr'0 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 29 14 29 45
let%span sreversal_raw_ptr'1 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 30 4 30 40
let%span sreversal_raw_ptr'2 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 13 14 13 28
let%span sreversal_raw_ptr'3 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 16 12 25 13
let%span sptr = "/home/baggabom/stage/creusot/creusot-contracts/src/std/ptr.rs" 99 22 99 44
let%span sptr'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/ptr.rs" 59 14 59 53
let%span sptr'1 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/ptr.rs" 61 8 61 35
let%span sseq = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 451 4 451 31
let%span sseq'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 449 14 449 36
let%span sseq'1 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 169 8 169 39
let%span sseq'2 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 673 20 673 95
let%span sghost = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 99 8 99 18
let%span sboxed = "/home/baggabom/stage/creusot/creusot-contracts/src/std/boxed.rs" 33 8 33 18
let%span sptr_own = "/home/baggabom/stage/creusot/creusot-contracts/src/ptr_own.rs" 49 8 49 35

use creusot.prelude.Opaque
use creusot.int.UInt64
use seq.Seq
use mach.int.Int
use creusot.prelude.Any

function addr_logic (self : Opaque.ptr) : UInt64.t

function is_null_logic (self : Opaque.ptr) : bool =
  [%#sptr'1] addr_logic self = (0 : UInt64.t)

axiom is_null_logic_spec : forall self : Opaque.ptr . [%#sptr'0] is_null_logic self = (addr_logic self = (0 : UInt64.t))

let rec null (return'  (x:Opaque.ptr))= any
  [ return''0 (result:Opaque.ptr)-> {[%#sptr] is_null_logic result} (! return' {result}) ]


type t_T

type t_Node  =
  { t_Node__elem: t_T; t_Node__next: Opaque.ptr }

type t_PtrOwn  =
  { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }

function ptr (self : t_PtrOwn) : Opaque.ptr

predicate invariant' (self : t_PtrOwn) =
  [%#sptr_own] not is_null_logic (ptr self)

predicate inv (_0 : t_T)

predicate inv'0 (_0 : t_Node)

axiom inv_axiom [@rewrite] : forall x : t_Node [inv'0 x] . inv'0 x
= match x with
  | {t_Node__elem = elem ; t_Node__next = next} -> inv elem
  end

predicate invariant''0 (self : t_Node) =
  [%#sboxed] inv'0 self

predicate inv'1 (_0 : t_Node)

axiom inv_axiom'0 [@rewrite] : forall x : t_Node [inv'1 x] . inv'1 x = invariant''0 x

predicate inv'2 (_0 : t_PtrOwn)

axiom inv_axiom'1 [@rewrite] : forall x : t_PtrOwn [inv'2 x] . inv'2 x
= (invariant' x
/\ match x with
  | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'1 val'
  end)

predicate invariant''1 (self : t_PtrOwn) =
  [%#sboxed] inv'2 self

predicate inv'3 (_0 : t_PtrOwn)

axiom inv_axiom'2 [@rewrite] : forall x : t_PtrOwn [inv'3 x] . inv'3 x = invariant''1 x

predicate invariant''2 (self : Seq.seq t_PtrOwn) =
  [%#sseq'2] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)

predicate inv'4 (_0 : Seq.seq t_PtrOwn)

axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq t_PtrOwn [inv'4 x] . inv'4 x = invariant''2 x

predicate invariant''3 (self :  (Seq.seq t_PtrOwn)) =
  [%#sghost] inv'4 self

predicate inv'5 (_0 :  (Seq.seq t_PtrOwn))

axiom inv_axiom'4 [@rewrite] : forall x :  (Seq.seq t_PtrOwn) [inv'5 x] . inv'5 x = invariant''3 x

let rec new (return'  (x: (Seq.seq t_PtrOwn)))= any
  [ return''0 (result: (Seq.seq t_PtrOwn))-> {[%#sseq] inv'5 result}
    {[%#sseq'0] result = (Seq.empty : Seq.seq t_PtrOwn)}
    (! return' {result}) ]


type tuple  =
  { _p0: Opaque.ptr; _p1:  (Seq.seq t_PtrOwn) }

predicate inv'6 (_0 : tuple)

axiom inv_axiom'5 [@rewrite] : forall x : tuple [inv'6 x] . inv'6 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'5 x1)

function val' (self : t_PtrOwn) : t_Node

function tail (self : Seq.seq t_PtrOwn) : Seq.seq t_PtrOwn =
  [%#sseq'1] Seq.([..]) self 1 (Seq.length self)

predicate list [#"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 14 4 14 68] (l : Opaque.ptr) (perm_seq : Seq.seq t_PtrOwn)


axiom list_def : forall l : Opaque.ptr, perm_seq : Seq.seq t_PtrOwn . list l perm_seq
= ([%#sreversal_raw_ptr'3] if is_null_logic l then
  Seq.length perm_seq = 0
else
  if Seq.length perm_seq > 0 then
    let ptr'0 = ptr (Seq.get perm_seq 0) in l = ptr'0 /\ list (val' (Seq.get perm_seq 0)).t_Node__next (tail perm_seq)
  else
    false

)

meta "compute_max_steps" 1000000

let rec empty[#"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 31 4 31 65] (return'  (x:tuple))= (! bb0
  [ bb0 = s0 [ s0 = null (fun (_ret:Opaque.ptr) ->  [ &_3 <- _ret ] s1) | s1 = bb1 ] 
  | bb1 = s0 [ s0 = new (fun (_ret: (Seq.seq t_PtrOwn)) ->  [ &_4 <- _ret ] s1) | s1 = bb2 ] 
  | bb2 = s0 [ s0 =  [ &_0 <- { _p0 = _3; _p1 = _4 } ] s1 | s1 = return''0 {_0} ]  ]
  ) [ & _0 : tuple = Any.any_l () | & _3 : Opaque.ptr = Any.any_l () | & _4 :  (Seq.seq t_PtrOwn) = Any.any_l () ] 
  [ return''0 (result:tuple)-> {[@expl:empty result type invariant] [%#sreversal_raw_ptr] inv'6 result}
    {[@expl:empty ensures #0] [%#sreversal_raw_ptr'0] list result._p0 result._p1}
    {[@expl:empty ensures #1] [%#sreversal_raw_ptr'1] is_null_logic result._p0}
    (! return' {result}) ]
  
