(* #"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 146 0 146 92 *)

let%span sreversal_raw_ptr = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 149 16 149 30
let%span sreversal_raw_ptr'0 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 155 16 155 24
let%span sreversal_raw_ptr'1 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 154 16 154 98
let%span sreversal_raw_ptr'2 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 153 16 153 66
let%span sreversal_raw_ptr'3 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 152 16 152 35
let%span sreversal_raw_ptr'4 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 150 16 151 115
let%span sreversal_raw_ptr'5 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 146 30 146 33
let%span sreversal_raw_ptr'6 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 146 46 146 92
let%span sreversal_raw_ptr'7 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 143 10 143 41
let%span sreversal_raw_ptr'8 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 144 10 144 44
let%span sreversal_raw_ptr'9 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 145 10 145 102
let%span sreversal_raw_ptr'10 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 31 22 31 65
let%span sreversal_raw_ptr'11 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 29 14 29 45
let%span sreversal_raw_ptr'12 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 30 4 30 40
let%span sreversal_raw_ptr'13 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 13 14 13 28
let%span sreversal_raw_ptr'14 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 16 12 25 13
let%span sreversal_raw_ptr'15 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 41 16 41 17
let%span sreversal_raw_ptr'16 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 41 39 41 42
let%span sreversal_raw_ptr'17 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 35 15 35 35
let%span sreversal_raw_ptr'18 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 36 14 36 40
let%span sreversal_raw_ptr'19 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 37 14 37 92
let%span sreversal_raw_ptr'20 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 38 14 38 39
let%span sreversal_raw_ptr'21 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 39 14 39 39
let%span sreversal_raw_ptr'22 = "/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 40 14 40 43
let%span sptr = "/home/baggabom/stage/creusot/creusot-contracts/src/std/ptr.rs" 59 14 59 53
let%span sptr'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/ptr.rs" 61 8 61 35
let%span sseq = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 169 8 169 39
let%span sseq'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/seq.rs" 673 20 673 95
let%span sghost = "/home/baggabom/stage/creusot/creusot-contracts/src/ghost.rs" 99 8 99 18
let%span sboxed = "/home/baggabom/stage/creusot/creusot-contracts/src/std/boxed.rs" 33 8 33 18
let%span sptr_own = "/home/baggabom/stage/creusot/creusot-contracts/src/ptr_own.rs" 49 8 49 35
let%span sresolve = "/home/baggabom/stage/creusot/creusot-contracts/src/resolve.rs" 49 20 49 34
let%span sinvariant = "/home/baggabom/stage/creusot/creusot-contracts/src/invariant.rs" 101 20 101 44
let%span svec = "/home/baggabom/stage/creusot/creusot-contracts/src/std/vec.rs" 21 14 21 41
let%span svec'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/vec.rs" 88 16 88 17
let%span svec'1 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/vec.rs" 89 26 94 17
let%span svec'2 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/vec.rs" 46 20 46 83
let%span svec'3 = "/home/baggabom/stage/creusot/creusot-contracts/src/std/vec.rs" 63 20 63 41
let%span ssnapshot = "/home/baggabom/stage/creusot/creusot-contracts/src/snapshot.rs" 50 20 50 39
let%span smodel = "/home/baggabom/stage/creusot/creusot-contracts/src/model.rs" 54 8 54 22
let%span smodel'0 = "/home/baggabom/stage/creusot/creusot-contracts/src/model.rs" 72 8 72 22
let%span sindex = "/home/baggabom/stage/creusot/creusot-contracts/src/logic/ops/index.rs" 29 8 29 31

use creusot.prelude.Opaque
use seq.Seq
use mach.int.Int
use creusot.int.UInt64
use creusot.prelude.MutBorrow
use creusot.prelude.Any

type t_T

type t_Node  =
  { t_Node__elem: t_T; t_Node__next: Opaque.ptr }

type t_PtrOwn  =
  { t_PtrOwn__ptr: Opaque.ptr; t_PtrOwn__val: t_Node }

type tuple  =
  { _p0: Opaque.ptr; _p1:  (Seq.seq t_PtrOwn) }

function addr_logic (self : Opaque.ptr) : UInt64.t

function is_null_logic (self : Opaque.ptr) : bool =
  [%#sptr'0] addr_logic self = (0 : UInt64.t)

axiom is_null_logic_spec : forall self : Opaque.ptr . [%#sptr] is_null_logic self = (addr_logic self = (0 : UInt64.t))

function ptr (self : t_PtrOwn) : Opaque.ptr

predicate invariant' (self : t_PtrOwn) =
  [%#sptr_own] not is_null_logic (ptr self)

predicate inv (_0 : t_T)

predicate inv'0 (_0 : t_Node)

axiom inv_axiom [@rewrite] : forall x : t_Node [inv'0 x] . inv'0 x
= match x with
  | {t_Node__elem = elem ; t_Node__next = next} -> inv elem
  end

predicate invariant''0 (self : t_Node) =
  [%#sboxed] inv'0 self

predicate inv'1 (_0 : t_Node)

axiom inv_axiom'0 [@rewrite] : forall x : t_Node [inv'1 x] . inv'1 x = invariant''0 x

predicate inv'2 (_0 : t_PtrOwn)

axiom inv_axiom'1 [@rewrite] : forall x : t_PtrOwn [inv'2 x] . inv'2 x
= (invariant' x
/\ match x with
  | {t_PtrOwn__ptr = ptr'0 ; t_PtrOwn__val = val'} -> inv'1 val'
  end)

predicate invariant''1 (self : t_PtrOwn) =
  [%#sboxed] inv'2 self

predicate inv'3 (_0 : t_PtrOwn)

axiom inv_axiom'2 [@rewrite] : forall x : t_PtrOwn [inv'3 x] . inv'3 x = invariant''1 x

predicate invariant''2 (self : Seq.seq t_PtrOwn) =
  [%#sseq'0] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'3 (Seq.get self i)

predicate inv'4 (_0 : Seq.seq t_PtrOwn)

axiom inv_axiom'3 [@rewrite] : forall x : Seq.seq t_PtrOwn [inv'4 x] . inv'4 x = invariant''2 x

predicate invariant''3 (self :  (Seq.seq t_PtrOwn)) =
  [%#sghost] inv'4 self

predicate inv'5 (_0 :  (Seq.seq t_PtrOwn))

axiom inv_axiom'4 [@rewrite] : forall x :  (Seq.seq t_PtrOwn) [inv'5 x] . inv'5 x = invariant''3 x

predicate inv'6 (_0 : tuple)

axiom inv_axiom'5 [@rewrite] : forall x : tuple [inv'6 x] . inv'6 x = (let {_p0 = x0 ; _p1 = x1} = x in inv'5 x1)

function val' (self : t_PtrOwn) : t_Node

function tail (self : Seq.seq t_PtrOwn) : Seq.seq t_PtrOwn =
  [%#sseq] Seq.([..]) self 1 (Seq.length self)

predicate list [#"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 14 4 14 68] (l : Opaque.ptr) (perm_seq : Seq.seq t_PtrOwn)


axiom list_def : forall l : Opaque.ptr, perm_seq : Seq.seq t_PtrOwn . list l perm_seq
= ([%#sreversal_raw_ptr'14] if is_null_logic l then
  Seq.length perm_seq = 0
else
  if Seq.length perm_seq > 0 then
    let ptr'0 = ptr (Seq.get perm_seq 0) in l = ptr'0 /\ list (val' (Seq.get perm_seq 0)).t_Node__next (tail perm_seq)
  else
    false

)

let rec empty (return'  (x:tuple))= any
  [ return''0 (result:tuple)-> {[%#sreversal_raw_ptr'10] inv'6 result}
    {[%#sreversal_raw_ptr'11] list result._p0 result._p1}
    {[%#sreversal_raw_ptr'12] is_null_logic result._p0}
    (! return' {result}) ]


type t_NonNull  =
  { t_NonNull__pointer: Opaque.ptr }

type t_Unique  =
  { t_Unique__pointer: t_NonNull; t_Unique__qy95zmarker: () }

type t_UsizeNoHighBit  =
  { t_UsizeNoHighBit__0: UInt64.t }

type t_RawVecInner  =
  { t_RawVecInner__ptr: t_Unique; t_RawVecInner__cap: t_UsizeNoHighBit; t_RawVecInner__alloc: () }

type t_RawVec  =
  { t_RawVec__inner: t_RawVecInner; t_RawVec__qy95zmarker: () }

type t_Vec  =
  { t_Vec__buf: t_RawVec; t_Vec__len: UInt64.t }

constant v_MAX : UInt64.t = (18446744073709551615 : UInt64.t)

function view (self : t_Vec) : Seq.seq t_T

axiom view_spec : forall self : t_Vec . [%#svec] Seq.length (view self) <= UInt64.t'int (v_MAX : UInt64.t)

function view'0 (self : t_Vec) : Seq.seq t_T =
  [%#smodel] view self

function view'1 (self : t_Vec) : Seq.seq t_T =
  [%#ssnapshot] view'0 self

predicate invariant''4 (self : t_T) =
  [%#sboxed] inv self

predicate inv'7 (_0 : t_T)

axiom inv_axiom'6 [@rewrite] : forall x : t_T [inv'7 x] . inv'7 x = invariant''4 x

predicate invariant''5 (self : Seq.seq t_T) =
  [%#sseq'0] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'7 (Seq.get self i)

predicate inv'8 (_0 : Seq.seq t_T)

axiom inv_axiom'7 [@rewrite] : forall x : Seq.seq t_T [inv'8 x] . inv'8 x = invariant''5 x

predicate invariant''6 (self : t_Vec) =
  [%#svec'3] inv'8 (view self)

predicate inv'9 (_0 : t_Vec)

axiom inv_axiom'8 [@rewrite] : forall x : t_Vec [inv'9 x] . inv'9 x = invariant''6 x

type t_Option  =
  | C_None
  | C_Some t_T

predicate invariant''7 (self : MutBorrow.t t_Vec) =
  [%#sinvariant] inv'9 self.current /\ inv'9 self.final

predicate inv'10 (_0 : MutBorrow.t t_Vec)

axiom inv_axiom'9 [@rewrite] : forall x : MutBorrow.t t_Vec [inv'10 x] . inv'10 x = invariant''7 x

predicate inv'11 (_0 : t_Option)

axiom inv_axiom'10 [@rewrite] : forall x : t_Option [inv'11 x] . inv'11 x
= match x with
  | C_None -> true
  | C_Some a_0 -> inv a_0
  end

function view'2 (self : MutBorrow.t t_Vec) : Seq.seq t_T =
  [%#smodel'0] view self.current

let rec pop (self_:MutBorrow.t t_Vec) (return'  (x:t_Option))= {[@expl:pop 'self_' type invariant] [%#svec'0] inv'10 self_}
  any
  [ return''0 (result:t_Option)-> {inv'11 result}
    {[%#svec'1] match result with
      | C_Some t -> view self_.final = Seq.([..]) (view'2 self_) 0 (Seq.length (view'2 self_) - 1)
      /\ view'2 self_ = Seq.snoc (view self_.final) t
      | C_None -> self_.current = self_.final /\ Seq.length (view'2 self_) = 0
      end}
    (! return' {result}) ]


let rec v_Some (input:t_Option) (ret  (field_0:t_T))= any
  [ good (field_0:t_T)-> {C_Some field_0 = input} (! ret {field_0})
  | bad -> {forall field_0 : t_T [C_Some field_0 : t_Option] . C_Some field_0 <> input} (! {false} any) ]


predicate invariant''8 (self : MutBorrow.t ( (Seq.seq t_PtrOwn))) =
  [%#sinvariant] inv'5 self.current /\ inv'5 self.final

predicate inv'12 (_0 : MutBorrow.t ( (Seq.seq t_PtrOwn)))

axiom inv_axiom'11 [@rewrite] : forall x : MutBorrow.t ( (Seq.seq t_PtrOwn)) [inv'12 x] . inv'12 x = invariant''8 x

let rec cons (e:t_T) (l:Opaque.ptr) (seq:MutBorrow.t ( (Seq.seq t_PtrOwn))) (return'  (x:Opaque.ptr))= {[@expl:cons 'e' type invariant] [%#sreversal_raw_ptr'15] inv e}
  {[@expl:cons 'seq' type invariant] [%#sreversal_raw_ptr'16] inv'12 seq}
  {[@expl:cons requires] [%#sreversal_raw_ptr'17] list l seq.current}
  any
  [ return''0 (result:Opaque.ptr)-> {[%#sreversal_raw_ptr'18] list result seq.final}
    {[%#sreversal_raw_ptr'19] forall i : int . 0 <= i /\ i < Seq.length (tail seq.final)
     -> Seq.get seq.current i = Seq.get (tail seq.final) i}
    {[%#sreversal_raw_ptr'20] (val' (Seq.get seq.final 0)).t_Node__elem = e}
    {[%#sreversal_raw_ptr'21] ptr (Seq.get seq.final 0) = result}
    {[%#sreversal_raw_ptr'22] Seq.length seq.final = Seq.length seq.current + 1}
    (! return' {result}) ]


predicate resolve (self : MutBorrow.t ( (Seq.seq t_PtrOwn))) =
  [%#sresolve] self.final = self.current

predicate resolve'0 (_0 : MutBorrow.t ( (Seq.seq t_PtrOwn))) =
  resolve _0

predicate resolve'1 (_0 : t_T)

function index_logic [@inline:trivial] (self : t_Vec) (ix : int) : t_T =
  [%#sindex] Seq.get (view self) ix

predicate resolve'2 (self : t_Vec) =
  [%#svec'2] forall i : int . 0 <= i /\ i < Seq.length (view self)  -> resolve'1 (index_logic self i)

predicate resolve'3 (_0 : t_Vec) =
  resolve'2 _0

meta "compute_max_steps" 1000000

let rec list_of_vector1[#"/home/baggabom/stage/creusot_rust/creusot/src/reversal_raw_ptr.rs" 146 0 146 92] (vec:t_Vec) (return'  (x:tuple))= {[@expl:list_of_vector1 'vec' type invariant] [%#sreversal_raw_ptr'5] inv'9 vec}
  (! bb0
  [ bb0 = bb1
  | bb1 = bb2
  | bb2 = s0 [ s0 = empty (fun (_ret:tuple) ->  [ &_7 <- _ret ] s1) | s1 = bb3 ] 
  | bb3 = s0
    [ s0 =  [ &l <- _7._p0 ] s1
    | s1 =  [ &seq <- _7._p1 ] s2
    | s2 =  [ &_vec0 <- [%#sreversal_raw_ptr] vec'0 ] s3
    | s3 = bb4 ]
  
  | bb4 = bb5
  | bb5 = bb5'0
    [ bb5'0 = {[@expl:loop invariant #0] [%#sreversal_raw_ptr'4] forall i : int . Seq.length (view vec'0) <= i
      /\ i < Seq.length (view'1 _vec0)
       -> (val' (Seq.get seq (i - Seq.length (view vec'0)))).t_Node__elem = Seq.get (view'1 _vec0) i}
      {[@expl:loop invariant #1] [%#sreversal_raw_ptr'3] list l seq}
      {[@expl:loop invariant #2] [%#sreversal_raw_ptr'2] Seq.length (view vec'0) + Seq.length seq
      = Seq.length (view'1 _vec0)}
      {[@expl:loop invariant #3] [%#sreversal_raw_ptr'1] forall i : int . 0 <= i /\ i < Seq.length (view vec'0)
       -> Seq.get (view vec'0) i = Seq.get (view'1 _vec0) i}
      {[@expl:loop invariant #4] [%#sreversal_raw_ptr'0] inv'5 seq}
      (! s0) [ s0 = bb6 ] 
      [ bb6 = bb7
      | bb7 = bb8
      | bb8 = bb9
      | bb9 = s0
        [ s0 = {inv'9 vec'0}
          MutBorrow.borrow_mut <t_Vec> {vec'0}
            (fun (_ret:MutBorrow.t t_Vec) ->  [ &_19 <- _ret ] -{inv'9 _ret.final}-  [ &vec'0 <- _ret.final ] s1)
        | s1 = pop {_19} (fun (_ret:t_Option) ->  [ &_18 <- _ret ] s2)
        | s2 = bb10 ]
      
      | bb10 = any [ br0 -> {_18 = C_None} (! bb14) | br1 (x0:t_T)-> {_18 = C_Some x0} (! bb11) ] 
      | bb11 = bb12
      | bb12 = s0
        [ s0 = v_Some {_18} (fun (r0:t_T) ->  [ &v <- r0 ] s1)
        | s1 = {inv'5 seq}
          MutBorrow.borrow_mut < (Seq.seq t_PtrOwn)> {seq}
            (fun (_ret:MutBorrow.t ( (Seq.seq t_PtrOwn))) ->
               [ &_26 <- _ret ] 
              -{inv'5 _ret.final}-
               [ &seq <- _ret.final ] 
              s2)
        | s2 = {inv'5 _26.current}
          MutBorrow.borrow_final < (Seq.seq t_PtrOwn)> {_26.current} {MutBorrow.get_id _26}
            (fun (_ret:MutBorrow.t ( (Seq.seq t_PtrOwn))) ->
               [ &_25 <- _ret ] 
              -{inv'5 _ret.final}-
               [ &_26 <- { _26 with current = _ret.final } ] 
              s3)
        | s3 = cons {v} {l} {_25} (fun (_ret:Opaque.ptr) ->  [ &_22 <- _ret ] s4)
        | s4 = bb13 ]
      
      | bb13 = s0
        [ s0 = {[@expl:type invariant] inv'12 _26} s1 | s1 = -{resolve'0 _26}- s2 | s2 =  [ &l <- _22 ] s3 | s3 = bb16 ]
      
      | bb16 = bb17
      | bb17 = bb5'0 ]
     ]
  
  | bb14 = s0
    [ s0 = {[@expl:type invariant] match _18 with
        | C_Some x -> inv x
        | _ -> true
        end}
      s1
    | s1 = -{match _18 with
        | C_Some x -> resolve'1 x
        | _ -> true
        end}-
      s2
    | s2 = {[@expl:type invariant] inv'9 vec'0} s3
    | s3 = -{resolve'3 vec'0}- s4
    | s4 = bb15 ]
  
  | bb15 = s0 [ s0 =  [ &_0 <- { _p0 = l; _p1 = seq } ] s1 | s1 = bb18 ] 
  | bb18 = return''0 {_0} ]
  )
  [ & _0 : tuple = Any.any_l ()
  | & vec'0 : t_Vec = vec
  | & l : Opaque.ptr = Any.any_l ()
  | & seq :  (Seq.seq t_PtrOwn) = Any.any_l ()
  | & _7 : tuple = Any.any_l ()
  | & _vec0 : t_Vec = Any.any_l ()
  | & _18 : t_Option = Any.any_l ()
  | & _19 : MutBorrow.t t_Vec = Any.any_l ()
  | & v : t_T = Any.any_l ()
  | & _22 : Opaque.ptr = Any.any_l ()
  | & _25 : MutBorrow.t ( (Seq.seq t_PtrOwn)) = Any.any_l ()
  | & _26 : MutBorrow.t ( (Seq.seq t_PtrOwn)) = Any.any_l () ]
  
  [ return''0 (result:tuple)-> {[@expl:list_of_vector1 result type invariant] [%#sreversal_raw_ptr'6] inv'6 result}
    {[@expl:list_of_vector1 ensures #0] [%#sreversal_raw_ptr'7] list result._p0 result._p1}
    {[@expl:list_of_vector1 ensures #1] [%#sreversal_raw_ptr'8] Seq.length result._p1 = Seq.length (view vec)}
    {[@expl:list_of_vector1 ensures #2] [%#sreversal_raw_ptr'9] forall i : int . 0 <= i /\ i < Seq.length (view vec)
     -> (val' (Seq.get result._p1 i)).t_Node__elem = Seq.get (view vec) i}
    (! return' {result}) ]
  
