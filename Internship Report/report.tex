\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.2cm]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage{styles}
\usepackage{url} 
\usepackage[bookmarks, colorlinks=false, pdfborder={0 0 0}, pdftitle={<pdf title here>}, pdfauthor={<author's name here>}, pdfsubject={<subject here>}, pdfkeywords={<keywords here>}]{hyperref} 
\usepackage{minted}
\usepackage{tikz}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{titlesec}
\usetikzlibrary{matrix, arrows.meta, positioning, fit}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}

% Indent subsections by 1em
\titlespacing*{\subsection}{1em}{1ex plus .2ex minus .2ex}{0.5ex}

% (Optional) Further indent subsubsections
\titlespacing*{\subsubsection}{2em}{1ex plus .2ex minus .2ex}{0.5ex}

\setlength{\parindent}{1.5em} % Re-enable paragraph indentation

% Reduce line spacing
\linespread{1.0}


\begin{document}
\input{title}

\pagenumbering{roman}
\tableofcontents

\newpage
\pagenumbering{arabic} 

\section{Introduction}

\subsection{\scol{The Laboratoire Méthodes Formelles (LMF)}}
\ident LMF is a joint research centre of University Paris-Saclay, CNRS, ENS Paris-Saclay, Inria, and CentraleSupélec. it's divided to multiple departments interested in various topics such as type systems, topology and quantum computing. My research project took place within \scol{Toccata's team} of the formal methods department. I worked on verification of programs with pointers under the supervision of Jean-Cristophe Filliâtre, Arnaud Golfouse and Paul Patault.

There are multiple verification tools widely used and developed at the LMF research center. Among these tools, we find Creusot and Why3.

\subsection{\scol{Le langage de preuve Creusot}}
\subsubsection{\scol{Introduction}}
\textsc{Creusot} is a formal verification language used to verify \textsc{Rust} code. It checks the safety of code against compile-time errors and runtime panics, integer overflows, and, more importantly, the logical correctness of the code, ensuring it adheres to its specifications.

\textsc{Creusot} operates on top of \textsc{Why3} indirectly by translating Rust code into an intermediate verification language known as \textsc{Coma}. It facilitates the verification, and it also gives \textsc{Creusot} access to the full access to \textsc{Why3}'s features.

Below is a simple example of \textsc{Creusot} code that verifies the correctness of the \texttt{SUM\_FIRST\_N} function.

\begin{figure}[h]
\centering
\begin{minipage}{0.95\linewidth}
\begin{minted}[linenos, fontsize=\footnotesize, bgcolor=gray!5]{rust}
extern crate creusot_contracts;
use creusot_contracts::*;

#[requires(n@ * (n@ + 1) / 2 < u32::MAX@)]
#[ensures(result@ == n@ * (n@ + 1) / 2)]
pub fn sum_first_n(n: u32) -> u32 {
    let mut sum = 0;
    #[invariant(sum@ * 2 == produced.len() * (produced.len() + 1))]
    for i in 1..=n {
        sum += i;
    }
    sum
}
\end{minted}
\caption{Creusot verification example: sum of first n natural numbers}
\label{fig:sum-example}
\end{minipage}
\end{figure}

\textbf{Explanation}: 

The function \textsc{sum\_first\_n} shown above computes the sum of the first \texttt{n} natural numbers. The expressions highlighted in yellow represent its specification:
\begin{itemize}
\item \textbf{Precondition:} It asserts that the sum of the first \texttt{n} natural numbers where \texttt{n} is provided as a parameter, does not overflow the capacity of the result type. This ensures that the final sum, which will be stored in the return variable will not exceed the capacity of the return type. The operator \texttt{@} converts machine integers into mathematical integers, which are unlimited, allowing us to use arithmetic theory.
\item \textbf{Postcondition:} It states that the returned result is equal to the expected mathematical value: \texttt{n * (n + 1) / 2}
\item \textbf{Loop invariant:} The expression \texttt{produced.len()} corresponds to the number of iterations performed so far, it effectively can play the role of the loop index by applying a transformation. The reason we cannot refer directly to the loop index is due to scoping limitations.
\end{itemize}
\subsubsection{\scol{Ghost code in \textsc{CREUSOT}}}
\textsc{Rust}'s ownership and borrowing principles make it difficult to use pointers in proofs. where the need for a notion of ghost code in such a language. Ghost code allows us to perform proofs that are not possible using only raw code and the logical world, especially when dealing with existential quantification, if we know how to construct the value we are seeking for the existential quantifier.

Recently, ghost code has been introduced in \textsc{Creusot}. The subtlety lies in the fact that ghost code is separate from the original code. Therefore, it can be safely erased at compile time, allowing only the original code and the corresponding logical formulas to be executed. This results in faster and safer proof verification. Below are some examples of how to write ghost code in \textsc{Creusot}.

\hypertarget{ghostcode}{}

\section{State of art}

\subsection{\scol{Reynolds article}}
Reynolds' article introduced a new concept in formal program verification: \emph{Separation Logic}, an extension of Hoare Logic that facilitates automatic proofs on low-level imperative programs that use shared mutable data structures, by reasoning about disjoint parts of the heap. It greatly simplifies the formalization and verification of many problems that are otherwise difficult to handle using traditional Hoare Logic, such as concurrency, memory management, and aliasing.
\\

Reynolds is particularly interested in the \hyperlink{reversal}{\texttt{in\_place\_reversal}$\dagger$} algorithm. He frequently discusses it in his research, as it is a very interesting algorithm for exploring formal proofs on mutable data structures with pointers.
\\

To prove properties of algorithms on data structures, it's usually not enough to rely only on the program's representation. We often build a logical model of the data and connect it to the program state using predicates. It's better if the logical model is inductive, because provers generally work better with inductive data structures, for instance, the intuitive logical modeling of lists are sequences, therefore we can write the following predicate to represent a list:


\begin{align}
\texttt{list}\ \epsilon\ \texttt{i} &\overset{\text{def}}{=}\ \texttt{i = nil} \\
\texttt{list}\ (a.\alpha)\ \texttt{i} &\overset{\text{def}}{=}\ \exists\ \texttt{j},\ \texttt{list}\ \alpha\ \texttt{j} \land\ \texttt{i} \hookrightarrow \texttt{a}
\end{align}


\texttt{i $\hookrightarrow$ a} means \texttt{i} points to \texttt{a}\\

We can generalize the definition of a list to list segments by passing a tuple of pointers instead of a single one. In this case, the first pointer represents the head of the sub-list, and the second pointer represents the queue of the sub-list.\\
One of key uses of separation logic can be show in case if we prohibit using \hyperlink{reversal}{\texttt{in\_place\_reversal}$\dagger$} on shared data structures, in this context, given the following precondition for in-place reversal: \texttt{list p $\alpha$}, the post-condition \texttt{list p }$\overline{\alpha}$ is not sufficient to ensure the correctness of the algorithm. consider the example in the figure below.

\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance=1cm and 1cm, 
    box/.style={
        rectangle, draw, minimum width=1cm, minimum height=0.6cm, rounded corners=2pt,
        font=\small, text centered
    },
    normal/.style={draw=blue!60},
    shared/.style={draw=red!60, thick},
    arrow/.style={-{Stealth[length=3mm]}, thick},
    label/.style={font=\bfseries}
]

% First diagram as a scope
\begin{scope}[local bounding box=first]
    % List A nodes
    \node[box, normal] (a1) {1};
    \node[box, shared, right=of a1] (shared3) {2};
    \node[box, shared, right=of shared3] (shared4) {3};

    % List B nodes
    \node[box, normal, below=1.2cm of a1] (b6) {4};
    \node[box, normal, right=of b6] (b7) {5};

    % List head labels
    \node[label, above=0.4cm of a1] (listA) {$\alpha$};
    \node[label, above=0.4cm of b6] (listB) {$\beta$};

    % Arrows for List A
    \draw[arrow] (listA) -- (a1);
    \draw[arrow] (a1) -- (shared3);
    \draw[arrow] (shared3) -- (shared4);

    % Arrows for List B
    \draw[arrow] (listB) -- (b6);
    \draw[arrow] (b6) -- (b7);
    \draw[arrow, bend right=45] (b7) to (shared3);

    % Null pointer
    \node[right=0.5cm of shared4, font=\small\ttfamily] (null1) {NULL};
    \draw[arrow] (shared4) -- (null1);

    % Brace for shared nodes
    \draw [decorate, decoration={brace, amplitude=8pt}]
      (shared3.north west) -- (shared4.north east) 
      node[midway, yshift=15pt, font=\scriptsize\color{red!80!black}] {Shared};
\end{scope}

% Second diagram as a scope, shifted right by 8cm (adjust as needed)
\begin{scope}[xshift=16cm, local bounding box=second]
    % List A nodes (right to left)
    \node[box, shared] (shared4b) {3};
    \node[box, shared, left=of shared4b] (shared3b) {2};
    \node[box, normal, left=of shared3b] (a1b) {1};
    
    % List B nodes
    \node[box, normal, below=1.2cm of a1b] (b6b) {4};
    \node[box, normal, right=of b6b] (b7b) {5};
    
    % List head labels
    \node[label, above=0.4cm of shared4b] (listAb) {$\overline{\alpha}$};
    \node[label, above=0.4cm of b6b] (listBb) {$\beta$};
    
    % Arrows for List A (reversed)
    \draw[arrow] (listAb) -- (shared4b);
    \draw[arrow] (shared3b) -- (a1b);
    \draw[arrow] (shared4b) -- (shared3b);
    
    % Arrows for List B
    \draw[arrow] (listBb) -- (b6b);
    \draw[arrow] (b6b) -- (b7b);
    \draw[arrow, dashed, color=red!70, bend right=45] (b7b) to (shared3b);
    
    % Null pointer at the end of the list
    \node[left=0.5cm of a1b, font=\small\ttfamily] (null1b) {NULL};
    \draw[arrow] (a1b) -- (null1b);
    
    % Brace for shared part
    \draw [decorate, decoration={brace, amplitude=8pt}]
      (shared3b.north west) -- (shared4b.north east)
      node[midway, yshift=15pt, font=\scriptsize\color{red!80!black}] {Shared};
\end{scope}
% Arrow between diagrams
\draw[->, thick, >=Stealth, shorten >=5pt, shorten <=5pt] 
  (first.east) -- node[above] {in\_place reversal} (second.west);
\draw[->, thick, >=Stealth, shorten >=5pt, shorten <=5pt] 
  (first.east) -- node[below] {of $\alpha$} (second.west);

\end{tikzpicture}

\caption{in\_place reversal on shared lists}
\label{fig:shared-lists}
\end{figure}
\newpage
So we need to provide a stronger precondition that prevents such cases. One possible way is:
\[
\texttt{list\ p\ }\alpha \ \land\ \forall\,\texttt{x},\, \alpha'.\ \texttt{list\ x\ } \alpha' \rightarrow \texttt{conflicting}(\texttt{x},\ \alpha',\ \texttt{p},\ \alpha) \rightarrow \texttt{x} = \texttt{nil}
\]

where \texttt{conflicting (p: Pointer) (seq: Sequence) (p': Pointer) (seq': Sequence)} is a predicate that returns \texttt{True} if the two provided lists share any nodes. It is defined as follows:
\begin{align}
\texttt{conflicting}\ \texttt{p}\ \texttt{emp}\ \texttt{p'}\ \alpha' &\overset{\text{def}}{=} (\texttt{p} = \texttt{nil}) \\
\texttt{conflicting}\ \texttt{p}\ \alpha\ \texttt{p'}\ \texttt{emp} &\overset{\text{def}}{=} (\texttt{p'} = \texttt{nil}) \\
\texttt{conflicting}\ \texttt{p}\ (a.\alpha)\ \texttt{p'}\ (a'.\alpha') &\overset{\text{def}}{=} (\texttt{p} = \texttt{p'}) \lor {} \nonumber \\
&\quad \texttt{conflicting}\ \texttt{p}\ \alpha\ \texttt{[p'+1]}\ \alpha' \lor {} \nonumber \\
&\quad \texttt{conflicting}\ \texttt{[p+1]}\ \alpha\ \texttt{p'}\ \alpha'
\end{align}

Here, \texttt{[e]} denotes the content of the address \texttt{e}.\\
We can clearly notice that the precondition, but also the invariant, and the post-condition become extremely complicated, even more, when the program runs in a concurrent context. This is where separation logic proves invaluable. By leveraging heap separation, the specifications become significantly clearer and simpler.\\

Although \textsc{Creusot} does not support Separation Logic, its principles can be emulated through the use of the \textsc{Rust} type system and ghost code.
The latter can be used to carry over separation logic principles that are implicitly guaranteed by the \texttt{Rust} type system into the logical world. To be more precise, let us consider the interface of \texttt{PtrOwn<T>::disjoint\_lemma} as an illustrative example.

\begin{figure}[h]
\centering
\begin{minipage}{0.9\linewidth}
\begin{minted}[linenos, fontsize=\footnotesize, bgcolor=gray!5]{rust}
/// Ensures two PtrOwns reference different memory locations
#[ghost]
#[ensures(own1.ptr().addr_logic() != own2.ptr().addr_logic())]
#[ensures(*own1 == ^own1)]
pub fn disjoint_lemma(own1: &mut PtrOwn<T>, own2: &PtrOwn<T>)
\end{minted}
\caption{\texttt{PtrOwn<T>::disjoint\_lemma} interface}
\end{minipage}
\end{figure}

This lemma is admitted as an axiom in \textsc{Creusot}, and what it does is verify that the two permissions correspond to two distinct pointers on the heap.
If this lemma were logical, it would not hold, because we quantify universally over \texttt{own1} and \texttt{own2}; therefore, one could be equal to the other, and the first post-condition would not be satisfied.
However, if we admit it as a ghost lemma, the \texttt{Rust} type system, within the context of ghost code prohibits having a mutable borrow and an immutable borrow to the same value.
Therefore, \texttt{own1} and \texttt{own2} are necessarily distinct, and the validity of the axiom follows (the second post-condition is not essential for conveying the idea).

There are, however, more specialized tools designed specifically for reasoning with Separation Logic. One such tool is \textsc{Viper}, a Rust verifier that supports Separation Logic. It is built on top of \textsc{Boogie}, an intermediate verification language (IVL) developed by Microsoft Research, and is widely used in the field of formal verification. The illustration below clarifies the relationships between these languages and their connection to Separation Logic.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
  node distance=0.8cm and 1.8cm,
  every node/.style={font=\sffamily\small},
  box/.style={draw, rectangle, rounded corners, minimum width=1.8cm, minimum height=0.8cm, align=center},
  ->, thick
]
% Nodes
\node[box] (creusot) {Creusot};
\node[box, right=of creusot] (viper) {Viper};
\node[box, below=of viper] (boogie) {Boogie};
\node[box, left=of boogie] (why3) {Why3};
\node[box, below left=0cm and 0.7cm of creusot] (comma) {Comma};
\node[box, below=of boogie] (smt) {SMT};
\node[box, right=0.8cm of boogie] (delphi) {Delphi};

% Arrows
\draw[-, dashed, red, line width=0.8pt] 
  (1.8,1.2) -- (1.8,-2.5);

\draw[-, dashed, red, line width=0.8pt] 
  (8,-2.5) -- (-3.5,-2.5);
  
\draw (creusot) -- (comma);
\draw (comma) -- (why3);
\draw (viper) -- (boogie);
\draw (why3) -- (smt);
\draw (boogie) -- (smt);
\draw (delphi) -- (boogie);



% Arrow pointing to Delphi
\draw[<-, dashed, blue] (delphi.east) -- ++(0.8,0.8) node[above, font=\tiny\sffamily, blue] {AWS services};
\draw[<-, dashed, blue] (viper.east) -- ++(0.8,0) node[right, font=\tiny\sffamily, blue] {ETH Zurich};

% Add explanatory labels
\node[above=0.1cm of creusot, align=center, font=\tiny\sffamily] (leftlabel) 
  {No Separation Logic};
\node[above=0.1cm of viper, align=center, font=\tiny\sffamily] (rightlabel) 
  {Support Separation Logic};
\node[left=0.1cm of smt, align=center, font=\tiny\sffamily] (rightlabel) 
  {Separation Logic has no meaning\\ at this level};
\end{tikzpicture}
\caption{Illustration of the relationship between verification tools and intermediate languages.}
\label{fig:verification-diagram}
\end{figure}

\subsection{\scol{Different ways of implementing the problem}}
The list reversal problem has already been proven in two different ways in \textsc{Creusot}, but both methods have certain limitations:

\begin{itemize}
\item \hypertarget{BOXmeth}{\textbf{\textsc{BOX} method}}: This approach models lists using \texttt{Rust Box} type. However, it imposes strong restrictions on the memory model by prohibiting any form of sharing or aliasing, since \texttt{Box} does not support multiple references to the same memory location. As a result, the specification is simple and the proof goes through easily.
\item \hypertarget{MEMmodel}{\textbf{Memory model method}}: This approach relies on modular reasoning over the memory. In other words, it involves passing an object that models the entire memory as a parameter to each method to be verified. As a result, verification requires reasoning about the complete memory state. This can quickly lead to complex proofs even for simple algorithms. For example, suppose we have two disjoint lists in the heap, each verified using a \texttt{list} predicate. If we reverse one of them, the \texttt{list} predicate on the other is not preserved automatically, and we must explicitly include it in the proof. This makes the verification process tedious. This is where separation logic becomes useful, and the solution we propose implicitly uses its principles, thanks to \textsc{Rust} type system.
\end{itemize}

\section{Problem definition and proposed solution}
\subsection{\scol{Problem definition}}
Formal verification of mutable data structures with pointers is one of the most challenging aspects of formal methods. The in-place list reversal algorithm is a canonical example of this challenge, as it can easily lead to memory leaks, dangling pointers, or logical errors.\\
The core problem is that, for a given list implementation in Rust using raw pointers, we need to formally verify the correctness of an in-place reversal algorithm not only that, but also the preservation of memory safety and the proper handling of shared lists.

\subsection{\scol{Proposed solution}}
\subsubsection{\scol{\texttt{PtrOwn} and \texttt{RawPtr}}} Formally called linear algebraic types, they are used by \textsc{Creusot} to manipulate pointers in proofs. \texttt{PtrOwn} models ownership of memory cells in the ghost world and can be used in parallel with \texttt{RawPtr}, which represents the corresponding address of the cell represented by \texttt{PtrOwn}. The internal representation of \texttt{PtrOwn} is as follows:

\begin{figure}[h!]
\begin{tikzpicture}[
    node distance=1cm,
    box/.style={rectangle, draw, minimum width=2cm, minimum height=0.8cm, text centered},
    field/.style={rectangle, draw, minimum width=1.8cm, minimum height=0.6cm, text centered, font=\small},
    arrow/.style={-{Stealth[length=3mm]}, thick}
]

% PtrOwn structure
\node[box, fill=blue!10] (ptrOwn) at (0,0) {\texttt{PtrOwn<T>}};

% Fields of PtrOwn
\node[field, below=0.5cm of ptrOwn] (ptrField) {\texttt{ptr: RawPtr<T>}};
\node[field, below=0.1cm of ptrField] (valField) {\texttt{val: T}};

% External RawPtr box
\node[box, fill=red!10, right=4cm of ptrOwn] (rawPtrBox) {\texttt{RawPtr<T>}};
\node[box, fill=red!10, below=1cm of rawPtrBox] (rawPtrBox2) {\texttt{RawPtr<T>}};
\node at ($(rawPtrBox)!0.5!(rawPtrBox2)$) {\vdots};


% Memory cell that RawPtr points to
\node[box, fill=green!10, right=3cm of rawPtrBox] (memoryCell) {Memory Cell};

% Arrows
% Beautiful curved arrows
\draw[thick, bend left=20] (ptrField.east) to node[midway, above] {\texttt{=}} (rawPtrBox.west);
\draw[thick, bend right=20] (ptrField.east) to  node[midway, above] {\texttt{=}} (rawPtrBox2.west);
\draw[arrow, bend left=15] (rawPtrBox.east) to (memoryCell.west);
\draw[arrow, bend right=15] (rawPtrBox2.east) to (memoryCell.west);

% Labels
\node[above=0.2cm of ptrOwn] {\texttt{Ghost World}};
\node at ($(rawPtrBox)!0.5!(memoryCell)$) [above=0.5cm] {\texttt{Program World}};


% Connecting lines for structure
\draw[thick] (ptrOwn.south) -- (ptrField.north);
\draw[thick] (ptrField.south) -- (valField.north);
% Vertical separator line
\draw[gray, thick, dashed] ($(ptrOwn.east)!0.5!(rawPtrBox.west) + (0,1.5)$) -- ($(ptrOwn.east)!0.5!(rawPtrBox.west) + (0,-2.5)$);


\end{tikzpicture}
\caption{Internal structure of \texttt{PtrOwn<T>}.}
\label{fig:ptrown-structure}
\end{figure}

Our solution relies on the use of linear algebraic types in \textsc{Creusot}, specifically, \texttt{PtrOwn} and \texttt{RawPtr}. This allows us to prove the correctness of in-place reversal even in the presence of shared data structures, making it better than the \hyperlink{BOXmeth}{BOX method$\dagger$}. Moreover, it also outperforms the \hyperlink{MEMmodel}{memory model$\dagger$} approach, our method requires to reason locally on memory. In other words, we only need to verify the parts of the heap we are manipulating, without having to reason about independent regions. This provides a form of separation logic, implicitly enforced by the Rust type system.\\
In the following we will present our solutions in steps.\\
\subsubsection{\scol{Data Structure}}
The list type is represented by \texttt{RawPtr<Node<T>>} where \texttt{Node<T>} is defined like the following:
\begin{minted}[linenos, fontsize=\footnotesize, bgcolor=gray!5]{rust}
struct Node<T> {
    elem: T,
    pub next: RawPtr<Node<T>>,
}
\end{minted}

\subsubsection{\scol{Predicates}}
\begin{itemize}
    \item \textbf{List Predicate}
        \hyperlink{list}{code$\dagger$}\\
        \texttt{list} predicate takes a pointer of type \texttt{RawPtr} and the abstract ghost sequence of permission \texttt{PtrOwn} that represents the list algebraically \texttt{seq}. it checks recursively that the pointers inside the permissions in the sequence correspond to the pointers in the progam world, and that the list ends with \texttt{nil}.\\
        \begin{align}
            &\texttt{list p \textbf{nil} $\overset{\text{def}}{=}$ p = null\_ptr()}\\
            &\texttt{list p (a.$\alpha$) $\overset{\text{def}}{=}$ p = a.ptr() $\land$ list [p+1] $\alpha$}
        \end{align}
    \item \textbf{inverse Predicate}  
    \hyperlink{inverse}{code$\dagger$}\\
    The predicate \texttt{inverse} takes two sequences of \texttt{PtrOwn} objects and determines whether the elements of the first sequence appear in reverse order in the second. One might notice that we could express this predicate more simply using the built-in \texttt{rev} function, as in \texttt{inverse(s1, s2) == inverse'(s1, s2)} where \texttt{inverse'(s1, s2) := s1.rev() == s2}. However, this is not the case due to our choice of the algebraic representation of the list and the invariants implied by the algorithm. We chose to model it as \texttt{Seq<PtrOwn<Node<T>>>},
    before explaining why the \texttt{rev} function is not applicable in this context, we first present a figure showing the structure of a \texttt{Seq<PtrOwn<Node<T>>>} and its corresponding representation in the program’s memory model.
    
    \begin{figure}[h]
    \centering
    % Option 1: Single tikzpicture with both diagrams
    \begin{tikzpicture}
        % Program World
        \node[font=\large\bfseries] at (3,8) {\texttt{Program World}};
        
        \draw (-2.5,6) rectangle (-1,6.75);
        \node[font=\small] at (-1.75,6.375) {\texttt{\colorbox{yellow}{RawPtr}}};
        \draw[->, thick, bend left=40] (-1,6.375) to (0,7.075);
        
        % First Node
        \draw (0,6) rectangle (0.5,7.5);
        \draw (0.5,6) rectangle (2,6.75);
        \draw (0.5,6.75) rectangle (2,7.5);
        \node[rotate=90, font=\small] at (0.25,6.75) {\texttt{Node}};
        \node[font=\small] at (1.25,7.125) {\texttt{v1}};
        \node[font=\small] at (1.25,6.375) {\texttt{RawPtr}};
        
        % Arrow to second node
        \draw[->, thick, bend left=40] (2,6.375) to (3,7.075);
        
        % Second Node
        \draw (3,6) rectangle (3.5,7.5);
        \draw (3.5,6) rectangle (5,6.75);
        \draw (3.5,6.75) rectangle (5,7.5);
        \node[rotate=90, font=\small] at (3.25,6.75) {\texttt{Node}};
        \node[font=\small] at (4.25,7.125) {\texttt{v2}};
        \node[font=\small] at (4.25,6.375) {\texttt{RawPtr}};
        
        % Arrow to third node
        \draw[->, thick, bend left=40] (5,6.375) to (6,7.075);
        
        % Third Node
        \draw (6,6) rectangle (6.5,7.5);
        \draw (6.5,6) rectangle (8,6.75);
        \draw (6.5,6.75) rectangle (8,7.5);
        \node[rotate=90, font=\small] at (6.25,6.75) {\texttt{Node}};
        \node[font=\small] at (7.25,7.125) {\texttt{v3}};
        \node[font=\small] at (7.25,6.375) {\texttt{nil}};
        
        % Dashed divider line
        \draw[dashed, thick] (-3,5) -- (8.5,5);
        
        % Ghost World
        \node[font=\large\bfseries] at (3.75,4.5) {\texttt{Ghost World}};
        
        % Manual grid lines for non-uniform rows
        % Vertical lines
        \draw[black, thick] (0,1) -- (0,4);
        \draw[black, thick] (2.5,1) -- (2.5,4);
        \draw[black, thick] (5,1) -- (5,4);
        \draw[black, thick] (7.5,1) -- (7.5,4);
        
        % Horizontal lines
        \draw[black, thick] (0,1) -- (7.5,1);     % Bottom
        \draw[black, thick] (0,2.5) -- (7.5,2.5); % Middle (taller second row)
        \draw[black, thick] (0,4) -- (7.5,4);     % Top
        
        % Column 1
        % First row - ptr: RawPtr (smaller height)
        \node[font=\small] at (1.25,3.25) {\texttt{\colorbox{yellow}{ptr: RawPtr}}};
        
        % Second row - Node struct (taller height)
        \draw (0.25,1.25) rectangle (0.75,2.25);
        \draw (0.75,1.25) rectangle (2.25,1.75);
        \draw (0.75,1.75) rectangle (2.25,2.25);
        \node[rotate=90, font=\small] at (0.5,1.75) {\texttt{Node}};
        \node[font=\small] at (1.5,2) {\texttt{v1}};
        \node[font=\small] at (1.5,1.5) {\texttt{RawPtr}};
        
        % Column 2
        % First row - ptr: RawPtr
        \node[font=\small] at (3.75,3.25) {\texttt{ptr: RawPtr}};
        
        % Second row - Node struct
        \draw (2.75,1.25) rectangle (3.25,2.25);
        \draw (3.25,1.25) rectangle (4.75,1.75);
        \draw (3.25,1.75) rectangle (4.75,2.25);
        \node[rotate=90, font=\small] at (3,1.75) {\texttt{Node}};
        \node[font=\small] at (4,2) {\texttt{v2}};
        \node[font=\small] at (4,1.5) {\texttt{RawPtr}};
        
        % Column 3
        % First row - ptr: RawPtr
        \node[font=\small] at (6.25,3.25) {\texttt{ptr: RawPtr}};
        
        % Second row - Node struct
        \draw (5.25,1.25) rectangle (5.75,2.25);
        \draw (5.75,1.25) rectangle (7.25,1.75);
        \draw (5.75,1.75) rectangle (7.25,2.25);
        \node[rotate=90, font=\small] at (5.5,1.75) {\texttt{Node}};
        \node[font=\small] at (6.5,2) {\texttt{v3}};
        \node[font=\small] at (6.5,1.5) {\texttt{nil}};
        
        Cross-reference arrows from Ghost World to Program World
        From Ghost World ptr fields to Program World RawPtr elements
    
        \draw[->, thick]
          (0.5,3.8)
          .. controls (0.8,5.5) and (1.2,4.1)
          .. (1.75,6);
        
        \draw[->, thick]
          (3,3.8)
          .. controls (3.4,5.5) and (4.1,4.1)
          .. (4.75,6);
        
        \draw[->, thick]
          (5.5,3.8)
          .. controls (6,5.5) and (7.1,4.1)
          .. (7.75,6);
        
        % Internal Ghost World arrows (within the grid)
        \draw[->, thick, bend left=30] (2.25,1.5) to (2.75,1.75);
        \draw[->, thick, bend left=30] (4.75,1.5) to (5.25,1.75);
        \draw[->, thick, bend left=30] (2.25,1.5) to (3.75,2.755);
    
        
        % Arrow from second node's RawPtr to third node
        \draw[->, thick, bend left=30] (4.75,1.5) to (6.25,2.75);
        
    \end{tikzpicture}
    
    
    \caption{Memory representation of a list with 3 elements with raw pointers and \texttt{Creusot} sequences.}
  \end{figure}
\newpage  
    \texttt{inverse} and \texttt{inverse'} are not equivalent predicates. The key difference is that \texttt{inverse} is independent of the second field of \texttt{PtrOwn} (\texttt{Node} field), whereas \texttt{inverse'} is not. In the \texttt{in\_place\_reversal} algorithm, we reverse the direction of the pointers inside the \texttt{Node} field of each \texttt{PtrOwn}. As a result, if we use the built-in \texttt{rev} function to reverse the sequence, it will not reconstruct the original version as it was at the beginning of the function, since the internal pointers now point in the opposite direction.  
    The predicate \texttt{inverse} avoids this problem by ignoring the second field entirely. It only checks the ordering of the elements in the list, which is the only relevant information we need to verify. This is precisely why we define and use this predicate.
  \end{itemize}

\section{Conclusion and perspectives}
\subsection{\scol{Conclusion}}
This work successfully addresses the challenge of formally verifying in-place linked list reversal in the presence of shared data structures using \textsc{Creusot}. I have learned many concepts through this research work, not only about formal verification but also about programming semantics and formal verification language compilation.

\subsection{\scol{Perspectives}}
We are looking forward to extending the proof to lasso structures and, more importantly, to proving the Morris tree traversal algorithm, which was my initial subject. Unfortunately, due to the complexity of the proof compared to the given time, I had to work on a simpler but very important algorithm, which is the list reversal.
\newpage

\begin{thebibliography}{9}

\bibitem{reynolds}
John C. Reynolds,  
\textit{Separation Logic: A Logic for Shared Mutable Data Structures},  
Proceedings of the 17th Annual IEEE Symposium on Logic in Computer Science (LICS), 2002.

\bibitem{morris}
Joseph M. Morris,  
\textit{Traversing Binary Trees Simply and Cheaply},  
Information Processing Letters, Vol. 9, No. 5, December 1979, pp. 197–200.
\end{thebibliography}
\newpage
\input{appendix}

\end{document}